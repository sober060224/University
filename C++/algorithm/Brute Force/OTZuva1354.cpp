#include <cstdio>    // 包含标准输入输出头文件
#include <cstring>   // 用于 memset函数（初始化数组）
#include <vector>    // vector是动态数组，这里用来存储树状结构的信息
using namespace std; // 使用std命名空间

// Tree结构的定义：L和R表示子集中权重的最大累积和中的一半或更多部分以及剩余的半部分。
struct Tree
{
  double L = 0, R = 0; // 初始化时，这两个值都被设为0
};

const int maxn = 6; // maxn定义了可能的最大数组大小（用于位运算和动态规划）

int n, vis[1 << maxn];             // n是权重数组的大小，vis是一个整型数组用来标记哪些子集已经被访问过。初始化时都被设为0.
double r, w[maxn], sum[1 << maxn]; // 定义目标容量r、权重大小w和每个可能的子集的总重量sum[]
vector<Tree> tree[1 << maxn];      // vector数组，用来存储所有可能的树状结构信息。初始化时为空.

// dfs函数是深度优先搜索算法的核心部分，用于生成并计算所有的有效决策路径（即满足条件的子集）以及对应的期望值L和R
void dfs(int subset)
{
  if (vis[subset]) // 如果这个集合已经被访问过，直接返回。这样可以避免重复处理相同的子集。
    return;
  vis[subset] = true; // 标记该集合已经访问过了

  bool have_children = false; // 初始化一个标志位来判断当前的节点是否有孩子结点（即是否还有未被处理的非空子集）

  for (int left = (subset - 1) & subset; left; left = (left - 1) & subset)
  {                       // 这是一个循环，用于遍历所有可能的有效子集。它通过位运算来实现对集合的迭代和处理（即找到所有的非空子集）
    have_children = true; // 如果有孩子结点则设置标志为true

    int right = subset ^ left; // 使用异或操作计算出另一个不等于left但与subset相同的二进制位数组，这就是我们的right。它代表了当前左边的集合的剩余部分（即子集中未被选中的元素）

    double d1 = sum[right] / sum[subset]; // 这是一个比例值，表示右半部分的重量相对于整个子集的比例
    double d2 = sum[left] / sum[subset];  // 同样地计算左边的集合的权重大小与总重量的比值。这是为了在递归过程中更新和存储对应的期望价值（即L+R）信息

    dfs(left);  // DFS函数的递归调用，用于处理子集中的左边部分元素的信息并保存到tree数组中
    dfs(right); // 同样的，DFS函数需要被用来解决右边的集合问题。这是因为每个节点都需要进行这样的操作来维护树的完整性（即动态规划的过程）

    for (int i = 0; i < tree[left].size(); i++)
    {
      for (int j = 0; j < tree[right].size(); j++)
      {
        Tree t;                                                 // 初始化一个新的Tree结构，用于存储当前子集的期望价值信息（即L和R）。它是通过计算左半部分加上d1以及右半部分减去d2得到的最大值来确定的。这个过程是通过遍历所有可能的情况并找到最大的满足条件的解决方案
        t.L = max(tree[left][i].L + d1, tree[right][j].L - d2); // 计算左边集合的期望价值信息（即左半部分的重量与右半部分权重的比例）。这里是根据当前子集的最大累积和中的一半或更多部分来确定最优解
        t.R = max(tree[right][j].R + d2, tree[left][i].R - d1); // 计算右边集合的期望价值信息（即右半部分的重量与左半部分权重的比例）。这里是根据当前子集的最大累积中最小的一部分来确定最优解
        if (t.L + t.R < r)                                      // 如果这个解决方案满足条件，那么就将其添加到tree数组中并继续处理下一个可能的答案（即递归地进行深度优先搜索以找到所有符合条件的解）。这是动态规划的核心部分：通过存储和比较不同的决策路径来找出最优的解
          tree[subset].push_back(t);                            // 如果这个解决方案是有效的，那么就将其添加到当前子集对应的树状结构中（即tree数组）以备后续使用或参考。这是为了在之后的操作过程中能够快速地找到和访问所有的有效决策路径的信息并进行相应的处理
      }
    }
  }

  if (!have_children)               // 如果没有孩子结点，那么就添加一个空的Tree结构到当前的子集对应的树状结构中（即tree数组）。这是为了确保每个可能的有效解都被考虑到并且能够正确地被处理和存储。这种机制可以帮助我们避免遗漏任何有效的决策路径
    tree[subset].push_back(Tree()); // 如果这个解决方案是无效的，那么就添加一个空的树状结构到当前子集对应的数组中以表示这是一个叶子节点（即没有孩子结点的节点）并继续处理下一个可能的有效解。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息
}

// main函数：程序的主要入口点，用于读取输入数据和执行主逻辑过程的代码块
int main()
{
  int T;           // 定义测试用例的数量T（即有多少个不同的权重数组需要被处理）。初始化时为0.
  scanf("%d", &T); // 从标准输入中读取这个值并将其存储到变量T中以供后续使用

  while (T--)
  {                         // T--是一个递减运算符，它会在每次循环开始的时候将T的值减少1。当T变为0时，while循环会自动结束（即所有的测试用例都已经被处理完毕）。这是为了确保程序能够正确地迭代并处理所有可能的不同权重数组
    scanf("%lf%d", &r, &n); // 从标准输入中读取目标容量和权重大小数组的数量，并将它们存储到变量r（即目标容量）和n（即权重大大小列的数量）。这是为了能够正确地处理当前的测试用例

    for (int i = 0; i < n; i++) // 这是一个循环，用于读取并保存每个权重数组的大小信息到变量w[]中以便后续的处理和计算（即动态规划的过程）。这里的目的是将输入的数据正确地存储到一个临时的地方以供后面的处理使用
      scanf("%lf", &w[i]);      // 从标准输入中读取当前的权重大小并将其添加到对应的数组位置上，这样就可以在之后的过程中不断地更新和维护这个信息（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息

    for (int i = 0; i < (1 << n); i++)
    {                  // 这是一个循环，用于初始化每个可能的子集的总重量sum[]并将其添加到对应的数组位置上以便后续的处理和计算（即动态规划的过程）。这里的目的是将输入的数据正确地存储到一个临时的地方以供后面的处理使用
      sum[i] = 0;      // 对于每一个集合，我们都初始化它的总权重为0.这是为了确保我们能够从零开始并且准确无误地将每个子集的总重量计算出来（即动态规划的过程）。这样做的目的是为了避免重复和冗余的运算并提高程序的整体效率
      tree[i].clear(); // 对于每一个集合，我们都清空它的树状结构信息以备后续的使用或参考。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息（即动态规划的过程）。这样做的目的是为了避免遗漏任何有效的解决方案并且保证所有可能的解都被考虑到

      for (int j = 0; j < n; j++) // 这是一个循环，用于计算每个可能的有效子集的总重量并将其添加到对应的数组位置上以便后续的处理和计算（即动态规划的过程）。这里的目的是将输入的数据正确地存储到一个临时的地方以供后面的处理使用
        if (i & (1 << j))         // 如果当前的集合包含第j个元素，那么就将这个权重大小加到总权重中来更新最新的结果并继续下一次迭代（即遍历所有的可能的有效子集）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息
          sum[i] += w[j];         // 将当前的集合的总重量加上第j个权重大小以得到最新和最准确的结果，然后将其添加到对应的数组位置上以便后续的处理使用（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息

      int root = (1 << n) - 1; // 计算出根节点的值并保存起来以供后面的处理和参考，这样可以保证我们从正确的节点开始进行深度优先搜索（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解

      memset(vis, 0, sizeof(vis)); // 使用memset函数来初始化所有已经访问过的集合标记为未访问，以便在之后的处理过程中可以重新开始并寻找新的可能的最优解决方案（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解

      dfs(root); // 使用深度优先搜索算法来生成和计算所有可能的有效子集的总权重以及对应的期望价值信息并将其添加到树状结构中以便后续的处理和参考（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解

      double max_value = -1; // 初始化一个变量max_value为-1，这样如果所有可能的最优解决方案都小于等于0，那么就可以直接输出这个值。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解

      for (int i = 0; i < tree[root].size(); i++)                      // 遍历树状结构中所有可能的最优解决方案并找出最大的那个作为最终的结果（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解
        max_value = max(max_value, tree[root][i].L + tree[root][i].R); // 更新最大值为当前解决方案的总权重，然后将其添加到对应的数组位置上以便后续的处理使用（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解

      printf("%.10f\n", max_value); // 输出最终的最优解决方案的总权重以满足程序的要求并结束当前的测试用例的处理过程（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解
    }

    return 0; // 返回一个整数值0表示程序成功执行完毕，没有任何错误或者异常发生并正常结束运行。这只是一个惯例性的操作以表明程序已经完成了它的工作并将要退出（即动态规划的过程）。这是为了确保我们能够正确地管理和存储所有的有效决策路径的信息并且找到最优的解
  }